title: memo.mm

2016,05/18: XOR,SR(Shift Right),SL(Shift Left)を追加

-----

2016,05/12: ちょっと整理した．ブレークポイントを
設定したり解除したりするAPIを作り，ステップモードを
廃止した．また，sm.initSM(...)とかをsm.init(...)に
した．でも，まだブレークポイントを操作するAPIの
テストは全部はやっていない．

あと，ブレークポイントで停止する時だけuiInfoを
提供するように変更した．

-----

2016,05/09: 構造体のようなデータ型を定義する機能をこの
StackMachineに持たせることを考えた時，JSONを上手く使うのが
良いのではないかと思うので，これを少し調べておく．

まず，JSON文字列を作る時，オブジェクトのキーはダブル
クオーテーションで囲んであげないとなんない．シングル
クオーテーションで代用することもできないのでJSON文字列
自体を作る時はシングルクオーテーションで囲むのが良さそう．
その文字列をオブジェクトに変換するには
`JSON.parse();`関数を使用する．この関数の引数は2つで，
2つ目は省略可能．

* 第1引数：JSON文字列
* 第2引数：データ変換用コールバック関数

`JSON.parse();`のかわりに`eval()`を使うという手もあるけど，
これはやめておいた方が良い．逆にオブジェクトをJSON文字列に
変換するには`JSON.stringify()`メソッドを使用する．このメソッドの
引数は3つで1つめ以外は省略可能．

* 第1引数：変換するオブジェクト
* 第2引数：関数か配列のどちらかを指定する
  + 関数：値を変換するためのコールバック関数
  + 配列：出力したいプロパティ名を指定
* 第3引数：整形用文字列（空白、タブ、改行）を指定。もしくは、空白の個数を数値で指定。

あと，実際にこれらのデータ型を使う時には，用意したオブジェクトを
プロトタイプとしてこれのコピーを作ってやれば良いと思う．なので，
これをやるための`Object.create()`関数を使うことになると思う．
この関数は引数に取ったオブジェクトをプロトタイプとする新しい
オブジェクトを生成するものなので，

ここまで来てやっと気がついたんだけど，ここで定義するデータ型は
単に他のデータ型の列にすべきで，階層的な部分は再帰的に定義して
やった方が良いのかもしれない．それとはじめて書くけど，この
StackMachine自体はデータ型のチェックは実装しなくて良いのでは
ないかと少し前から思い初めている．データ型に関してはもう一度
ドラゴン本を見てみた方が良さそうだな．

-----

2016,05/07: 2016,04/16に言ってたBPとLINEとLABELの命令だけど，
やっぱり別文法で対応することにした．これら3つの命令は全部
別々の物ではなく同じ「`#@LABEL [ラベル名] [行番号]`」という
記述で書きあらわすことにして統一する．ラベル名はジャンプ先
として指定する時の名前で，行番号はソースファイルでの行を
表す．ラベル名はアルファベットで初まらなければならない
ものとし，ダブルクオーテーションで囲む必用はない．行番号は
整数でなければならない．この記述は通常の
命令の右に付け足す感じで実行に関係ない物とし，これを
付けないといけないのは以下の時．

* JUMPやCALLなどでジャンプする先としてラベルが必用な時．
  + この場合ラベル名は必須で行番号は省略可能
* ブレークポイントとして止めることができる場所
  + この場合ラベル名は省略可能で行番号は必須．
    実際にその場所でブレークするかどうかは
    ユーザーが決めることとなるので，ユーザーが
    ブレークさせる可能性があるところ全部にこれを
    付けてあげないといけないという仕様にしておく．
* 上記2つの必用がある時
  + ラベル名，行番号ともに必須．

この変更にしたがって，ユーザーにブレークポイントを設定
できるようにするAPIを提供しなければならない．(ブレーク
ポイントを解除するAPIとか，全部のブレークポイントを
解除するAPIとか，全部のブレークポイントを有効化する
APIも作るべし．)

これに従い，LABELとLINE命令は廃止する．けどBP命令は
何かの役に立つかもしれないので残しておくことにする．

上記作業の前にプログラムを文字列で読み込みできるように
しておくべし．

これができたら，あとは構造体のサポートだけかな．

01: /* 想定されるC言語のソース */
02: int i,n;
03: printf("繰り返し回数を入力:");
04: scanf("%d",&n);
05: for (i=0;i<n;i++) {
06:   printf("Hello World!\n",i);
07: }
08:

VAR i #@LABEL 2
VAR n
PUSH "繰り返し回数を入力:" #@LABEL 3
PRINT
INPUT_WAIT #@LABEL 4
SCANI
SET n
PUSH 0 #@LABEL 5
SET i
GET i #@LABEL L1 5
GET n
GE
IFJUMP L2
PUSH "Hello World!\n" #@LABEL 6
PRINT
GET i
INC
SET i
JUMP L1
FREE i #@LABEL L2 8
FREE n

あれ，なんでJUMPとIFJUMPの後のオペランドにダブルクオーテーション
必用なくなったんだ？まあ，この方がいいか．とりあえず動くところまでは
いった．けっこう大変だった．あとユーザがブレークポイントを
設定するAPIを用意するのはまだ．

-----

2016,05/01: ジャンプ先とかに使用しているLABELのオペランドは
整数を仮定していたけど，任意の文字列を指定できるように変更する．

-----

2016,04/16: BPとLINEとLABELは通常命令ではないわけで，
これを命令とするかわりに拡張された文法として実装した
方が良いかもと思いはじめているけど，いや，そんな必用は
ないかもしれない．

ということで，今日からスコープの実装を少しづつ書いて
みようかと思う．このスコープの実装を上手く作れば
CALLとRETも簡単に実現できるでしょう．ただ，このへんの
実装は言語ごとに違ってくるので，コンパイラの方で
実装すべきなんだけど，そうだとすると面倒なことになりそう．

でも，最近の普通の言語なら，レキシカルスコープを想定して
おけばだいたいOKだと思われるので，やっぱりこっちで実装
することにする．しかもレキシカルスコープで作っとけば
動的スコープに対応するのも簡単だったので両方できるように
しておく．

だんだん考えていたらスコープの中には色々な
物を入れてあげると良い気がしてきた．スコープというよりは
ドラゴン本IIでいうところの駆動レコードだな．(StackMachine.jsの
内部的にはScopeをActRecと書き変えたけど，以下の`NEW_SCOPE`と
`POP_SCOPE`はまた後で書き換える．それと，この文章もね)．
(最初，このスコープの中にスタックマシンが
使うスタックを置いてスコープごとに新しくするアイディアを
思い付いて，良いアイディアだと思ったたけど，これは今作ってる
Cコンパイラがスタックにゴミを残すからであって，良く考えると
面倒だし，コンパイラの方をちゃんと直すことにしよう．)
それから，この実装ではレキスカルスコープを手軽に実装する
ために，このスコープの中に自分のスコープ名と，レキスカル
スコープ上での親スコープの名前を保存することにする．そして
topActRecのス駆動レコード名は「`@GLOBAL@`」決め打ちにさせてもらう．

* `NEW_AR` (新駆動レコード名 親駆動レコード名 - )
  + 新しい駆動レコード(Activation Record)を作製し現在の
    駆動レコードとする．`NEW_AR`は
    関数呼出とかでなはいようなスコープ生成を想定したもの．
    新しい駆動レコードの親レコードとか，新しい駆動内で使用する
    データの初期化も行う．
* POP_AR
  + 現在のカレント駆動レコードを捨てて，親駆動レコードを現在の
    駆動レコードとする．クロージャとかが参照してれば捨てられた
    駆動レコードも消えることはないけど，参照されてなければGCに
    回収されるかもしれない．
* CALL "ラベル" (引数1 引数2 … 新駆動レコード名 親駆動レコード名 - 返り値1 … )
  + まず，`NEW_AR`と同じ処理をして，returnPPにこのCALLの次の命令の
    PSを帰ってくる場所として保存して，最後ラベルのところに
    ジャンプする．
* RET
  + 現在の駆動レコードに保存されているreturnPPを一時変数に保存して，
    POP_ARと同じ操作をする．そして一時変数にに保存してあった値を
    プログラムポインタにセット(その番地にジャンプ)

### NEW_AR,POP_ARのサンプル

int i=10;
int j=20;
printf("%d\n",i);
{
  printf("%d\n",j);
  int i= 100;
  printf("%d\n",i);
}
printf("%d\n",i);

VAR i
PUSH 10
SET i
VAR j
PUSH 20
SET j
GET i
PRINT
PUSH "\n"
PRINT
PUSH "S1"
PUSH "@GLOBAL@"
NEW_AR
GET j
PRINT
PUSH "\n"
PRINT
VAR i
PUSH 100
SET i
GET i
PRINT
PUSH "\n"
PRINT
POP_AR
GET i
PRINT
PUSH "\n"
PRINT

### CALL,RETのサンプル(1)

スコープのテスト無し

printf("%d\n",s1(10));
printf("%d\n",s1(100));
int s1(int i) {
  return i+1;
}

PUSH 10
PUSH "S1"
PUSH "@GLOBAL@"
CALL "L0"
PRINT
PUSH "\n"
PRINT
PUSH 100
PUSH "S1"
PUSH "@GLOBAL@"
CALL "L0"
PRINT
PUSH "\n"
PRINT
JUMP "L1"
LABEL "L0"
PUSH 1
ADD
RET
LABEL "L1"

### CALL,RETのサンプル(1)

スコープのテストも含む

var i="A\n";
var j="X\n";
printf("%d\n",s1(10));
printf("%d\n",s1(100));
printf("%s\n",i);
printf("%s\n",j);
int s1(int x) {
  var i = "B\n";
  printf("%s\n",i);
  printf("%s\n",j);
  return x+1;
}

VAR i
PUSH "A\n"
SET i
VAR j
PUSH "X\n"
SET j
PUSH 10
PUSH "S1"
PUSH "@GLOBAL@"
CALL "L0"
PRINT
PUSH "\n"
PRINT
PUSH 100
PUSH "S1"
PUSH "@GLOBAL@"
CALL "L0"
PRINT
PUSH "\n"
PRINT
GET i
PRINT
GET j
PRINT
JUMP "L1"
LABEL "L0"
VAR i
PUSH "B\n"
SET i
GET i
PRINT
GET j
PRINT
PUSH 1
ADD
RET
LABEL "L1"

2016,04/24:よっしゃ！OKみたい．

-----

2016,04/13: vm.jsという名前で作ってきたけど，VMという
名前だと文句が出そうなので，スタックマシン(StackMachine.js)
と名称変更して続きを書くことにする．

以下，VMの時のメモ

-----

2016,04/04: UI部分を先にやるためにuiListenerに返すデータを
文字列でなくオブジェクトに変更．

-----

2016,03/22: 宿題をやる．

* 比較演算子の結果を-1と0にする
* IFJUMPの書き換え
* ビット演算子の追加

上はやったつもりだけど十分にテストしていない．
以下はまだやってない宿題．

* CALLとRETの実装．RETの実装は
  スタックに積まれているゴミを消すことにもなる．

-----

2016,03/20:コンパイラの実装はじめたら色々問題
みつかった．

* DUPとかSWAPとかのスタック操作命令が絶対欲しい
    + とりあえずDUP,SWAP,DROP
* 今，比較演算子の結果はtrue,falseだけど，整数値の方が
  良いのかもしれない．gforthを真似するのがいいかな？
  ちなみに．．．
    + gforthは真が-1で偽が0．
    + Z80なら結果はフラグに保存される．
    + C言語は真が1で偽が0．
* AND,OR,NOTのビット演算を実装．比較演算子をgforthと
  同じにすれば，ある程度ビット演算子で，論理演算子の
  代わりになるのでそうしちゃおう．
* 真偽値の表現変えたらIFJUMPの命令の書き換えも忘れずに
* ちなみに，JavaScriptのビット演算子は32ビットみたい．
    + <https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators>
    + すべてのビット演算でオペランドは符号付き 32 ビット演算に、ビッグエンディアンおよび 2 の補数形式で変換されます。

-----

2015,12/29:やっぱりプロシージャ呼び出し？の機能，
つまりポログラムカウンタをスタックに積んで
CALLしてRETで戻ってくる命令も必用では？

-----

2015,09/18:配列が扱えないので使えるようにした．
あと必用なこととして，オブジェクト指向を
やるならヒープ領域に関することもやっとか
ないとなんない．それに加えてC言語のポインタの
実装はどうしよう．sizeofも問題だ．

-----

2015,09/17,18:00:思ったより上手くいきそう．
次の段階として必用なのはterminalizeに依存しないよう，
一行出力用関数と一行入力用の関数を初期化の
段階で登録するようにすること．いや，入力の方は
VMに関数を用意して，そこを呼び出してもらうように
した方が良いな．そして，通常の
ブレークポイントとはまた別の入力待ち用の
ブレークポイントを用意するべし．

-----

2015,09/17: ステップ実行するには簡単なVMを作った方が
実は楽じゃないかと思ったので作ってみることに．

よく考えるとVMといったら誰かに何か言われそうな
感じなので簡易スタックマシンと言うぐらいが
いいかもしれない．

なるべくどんな言語にも対応できる物にしたい．
ここでは変数は型無しで実装する．型がある言語の場合
構文解析の段階でチェックするべし．型無しなので，
自動キャストとかすることになるけど，本当は
言語ごとに異ってくるかもしれないけど，とりあえず
目をつぶる．あと，変数のルックアップは，特に
関数型言語とかを実装する時には問題になるけど，
これも今は目をつぶる．それから標準入出力の部分も
言語ごとに作らないとダメか．盲目になるしかないね．

スタックマシンということなんで，以下のような
命令セットを作ることにする．ステップ実行に必用な
物とかも入ってくる．SCAN系は言語に応じて増やさないと
なんないかもしれない．

* 変数宣言
* 変数を開放
* スタック操作
  + データをスタックにプッシュ
  + スタックから1つデータを消去(POPというよりDROP)
  + スタックの一番上のデータを複製
  + スタックの一番上と2番目を交換
* 計算(スタックベースがいいかも)
  + 四則演算とか
  + 条件判定
  + ビット演算(場合によっては論理演算にも使える)
  + シフト演算(ローテート演算はいるか？)
  + スタックのトップを変数へ代入
  + 変数の中をスタックにプッシュ
* JUMP，条件付きJUMP，JUMP先のラベル
* 標準出力
* 標準入力
* ブレイクポイント
* 入力待ち用のブレイクポイント
* NOP
* 行番号記録
  + ステップ実行でUIに元のソースの
    実行箇所を示させたい時に必用になる
  + 注意点として，ループ処理などジャンプ
    するような場合にも行番号が上手く
    表示されるように，この命令を入れる
    場所をちゃんと考慮しないとなんない．
* 行列宣言
* 行列に代入
* 行列参照
* 行列開放

-----

* VAR 変数名
* FREE 変数名
* スタック操作
  + PUSH データ
  + DROP
  + DUP
  + SWAP
* 計算
  + ADD SUB MUL DIV MOD INC DEC
  + LT LE EQ GE GT NEQ
  + AND OR NOT XOR
  + SR(Shift Right) SL(Shift Left)
  + SET 変数名 (レキシカルスコープ)
  + GET 変数名 (レキシカルスコープ)
  + SET2 変数名 (動的スコープ)
  + GET2 変数名 (動的スコープ)
* ジャンプ
  + LABEL "ラベル名"
  + JUMP "ラベル"
  + IFJUMP "ラベル"
* PRINT
* SCANI //整数
* SCANF //実数
* SCANS //文字列(とりあえず一行？)
* SCANC //文字
* BP
* INPUT_WAIT
* NOP
* LINE 行番号
* ARRAY 行列変数名
* ARRAY_SET 行列変数名 (添え字 値 - )
* ARRAY_GET 行列変数名 (添え字 - 値 )
* FREE_ARRAY 行列変数名

-----

    01: /* コメントなんぞ入れてみる */
    02: int i,n;
    03: printf("繰り返し回数を入力:");
    04: scanf("%d",&n);
    05: for (i=0;i<n;i++) {
    06:   printf("Hello World!\n",i);
    07: }
    08:

-----

ブレークポイントどこに入れようか？Visual Studio
とか見てみると，行ごとに設定できるようになっていて
その行の実行前にストップするみたい．とりあえず
行が実行される前全てに入れてみるか．for分の
ところが鬼畜だな．行番号が正しく表示されるには
LINE命令の後にブレークポイントを入れないと
なんないね．LINE命令を入れる場所もジャンプも考慮
して，1つの行で複数入れないといけない時がある．
通常のブレークポイントと入力待ちのブレーク
ポイントはどうするのがベストか？

    LINE 1
    LINE 2
    BP
    VAR i
    VAR n
    LINE 3
    BP
    PUSH "繰り返し回数を入力:"
    PRINT
    LINE 4
    BP //必用か？
    INPUT_WAIT
    SCANI
    SET n
    LINE 5
    BP
    PUSH 0
    SET i
    LABEL "L1"
    LINE 5
    BP
    GET i
    GET n
    GE
    IFJUMP "L2"
    LINE 6
    BP
    PUSH "Hello World!\n"
    PRINT
    LINE 5
    BP
    GET i
    INC
    SET i
    JUMP "L1"
    LABEL "L2"
    FREE i
    FREE n
    LINE 8
    BP

40行もあってLINEとBPだらけだな．ちょっと取ってみる．
そしたら23行．

    VAR i
    VAR n
    PUSH "繰り返し回数を入力:"
    PRINT
    INPUT_WAIT
    SCANI
    SET n
    PUSH 0
    SET i
    LABEL "L1"
    GET i
    GET n
    GE
    IFJUMP "L2"
    PUSH "Hello World!\n"
    PRINT
    GET i
    INC
    SET i
    JUMP "L1"
    LABEL "L2"
    FREE i
    FREE n

-----

配列を使ったやつを考えてみる．

    01: int i;
    02: int test[3];
    03: test[0] = 10;
    03: test[1] = 20;
    03: test[2] = 30;
    03: for (i=0;i<3;i++) {
    04:   printf("%d\n",test[i]);
    05: }
    06:

とりあえず，LINEとBP無しで．

    VAR i
    ARRAY test
    PUSH 0
    PUSH 10
    ARRAY_SET test
    PUSH 1
    PUSH 20
    ARRAY_SET test
    PUSH 2
    PUSH 30
    ARRAY_SET test
    PUSH 0
    SET i
    LABEL "L1"
    GET i
    PUSH 3
    GE
    IFJUMP "L2"
    GET i
    ARRAY_GET test
    PRINT
    GET i
    INC
    SET i
    JUMP "L1"
    LABEL "L2"
    FREE i
    FREE_ARRAY test
